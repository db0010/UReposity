> <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210313225348529.png" alt="image-20210313225348529"  />
>
> ![image-20210313225405487](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210313225405487.png)
>
> ![img](https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif)

### 一、ArrayList

- 是一个长度可以动态改变的数组；当ArrayList满的时候，会创建一个更大的数组，然后把旧数组中的所有元素复制到新数组中去，紧接着用新数组取代旧数组扩容机制：第一次为0时扩为10，size达到11时，以上次容量的1.5倍扩容

- ```java
  //先在add方法中把下标加1，再在后续的grow方法中比较是否大于容量
  public boolean add(E e) {
  ensureCapacityInternal(size + 1);  //Increments modCount!!
      elementData[size++] = e;
         return true;
  }
  private static int calculateCapacity(Object[] elementData, int minCapacity) {
       if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) 			{
              return Math.max(DEFAULT_CAPACITY, minCapacity);
       }
          return minCapacity;
   }
  
  ```

 private void ensureCapacityInternal(int minCapacity) {
           ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
 }
    

```java
private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
        // 扩容时机：当size+1后大于原数组容量大小时，即minCapacity>elementData.length时扩容
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
}
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        //再根据计算得到的1.5倍的新容量来创建一个新数组，把数据移动过去
    elementData = Arrays.copyOf(elementData, newCapacity);
}
​```
```


​    

  - 用ArrayList()创建的对象初始大小为0，在调用boolean add(Object e)方法时才把默认容量10赋值给该对象的容量属性，ArrayList(int initalCapacity)可以指定对象的初始容量大小

  - 只有add()添加操作的时间复杂度是常数级别的，其他操作都是线性级别

    - 调用add方法的执行流程

  - ArrayList不是线程安全的，Vector跟ArrayList基本一样的，只是它是线程安全的，要达到线程安全的目的，可以使用Conllections.synchrinizedList方法包装，这样的ArrayList对象就是线程安全的；例如

    ```java
    List list = Collections.synchronizedList(new ArrayList(...)); 
    ```

  - sort(Comparator<? super E> c)：使用Comparator来排序通过比较

  - List<E> subList(int fromIndex,int toIndex)：左右都是闭区间，返回的是切割的数组的视图

  - Object[] toArray()：返回一个新的数组，所有的数据移动到新数组之后，旧数组就不能用了；数组转换成列表用List<T> Arrays.aList(T a)方法，返回的列表是可序列化的

    ![image-20210430162810394](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210430162810394.png)

    ![image-20210430162901909](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210430162901909.png)

### 二、LinkedList

- 该类实现了List、Deque接口，是一个双向链表，可以从前后添加和删除元素，如addFirst(),addLast(),removeFirst(),removeLast();也有类似栈的方法pop()删除第一个元素，push(E e)在列表前面插入元素；相比与ArrayList的常用方法有个contains(Object o),clone()浅拷贝，indexOf(Object o)返回参数对象所在集合的索引;初始容量为0

  ![image-20210501152446169](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210501152446169.png)

  - 扩容就是new一个Node<E>结点，所以在有大量插入时LinkedList不合适，每次都要New

  ![image-20210501145221765](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210501145221765.png)

  ![image-20210501145244473](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210501145244473.png)

- List中的contains(Object o)方法里面的比较不是用“==”比较（比较的是内存地址）的，而是用的equals()方法比较（比较的是值），在contains(Object o),indexOf(Object o)这些方法中传入的对象所在类需要重写了equals()方法才行，基本数据类型和类似String类型JDK都重写了的，自定义的类就需要自己重写了

- 例如

  ```java
  public boolean equals(Object o) {
   if (o instanceof Person) {
          Person p = (Person) o;
       return this.name.equals(p.name) && this.age == p.age;
      }
   return false;
  }
  ```

  对于引用字段就使用equals()方法来比较，对于基本数据类型就使用“==”来比较；

  |                          | ArrayList              | LinkedList           |
  | :----------------------- | :--------------------- | -------------------- |
  | 获取指定元素             | 速度很快（根据下标）   | 需要从头开始查找元素 |
  | 添加元素到末尾           | 速度很快（常数复杂度） | 速度很快             |
  | 在指定位置添加/删除      | 需要移动元素           | 不需要移动元素       |
  | 内存占用（根据情况讨论） | 少                     | 较大                 |

- 对List的遍历

  - for循环；注意其中的List.of()方法是JDK9的新特性，只有JDK9版本以上才能使用，作用是创建少量的不可变的元素的集合；不能做修改操作，是只读的；LinkedList对于for循环在10万数据量时时间无穷大，LinkedList千万不能使用for循环遍历，LinkedList使用迭代器遍历最快

    ```java
     List<String> list = List.of("apple", "pear", "banana");
            for (int i=0; i<list.size(); i++) {
             String s = list.get(i);
                System.out.println(s);
            }
    ```

  - Iterrater迭代器遍历:List接口实现了Iterator接口，可以是iterator()方法获取迭代器对象；List中使用迭代器遍历时最高效的

    ```java
     List<String> list=List.of("apple","pear","banana")
      for(Iterator<String> it=list.iterator();list.hasNext();){
      		String s = it.next();
          System.out.println(s);
      }
    ```

  - forEach遍历；java的forEach循环本身就帮我们使用了Iterater迭代器

    ```java
    List<String> list = List.of("apple", "pear", "banana");
            for(String str:list) {
                String s = list.get(i);
                System.out.println(s);
         
           }
    ```

![](D:\zuo_mian\java小知识\image\ArrayList.png)

### 三、TreeSet

### 二、hashMap的实现原理

> ![img](https://img-blog.csdn.net/20160605101246837?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

1. hashMap底层是由数组+链表或者是数组+红黑树（JDK8以上才有红黑树的）；当链表超过阈值（大于8）时，链表就会自动转化为红黑树，加快了查找速度；

   - ```java
     transient Node<k,v>[] table;//存储（位桶）的数组</k,v>
      static class Node<K,V> implements Map.Entry<K,V> {
             final int hash;
             final K key;
           V value;
             Node<K,V> next;}
     ```

   ```
     
     数组是Node<K,V>类型的，并且被transient修饰，表示这数组是不能够被序列化的；实现了Map.Entry<k,v>接口
     
   - 链表是单向链表
   
   - 红黑树（特点是查询时间是O（logn））
   
   - hashMap查找速度快的原因是，通过key值的hashCode()找到对应索引的数组单元；使用的是用空间换时间
   ```

2. hashMap的扩容机制

   - 填充比（又叫加载因子）默认为0.75，表示当Node<k,v>数组的长度达到length*填充比，则数组的容量就会扩充一倍，数组的初始大小为16；扩容比较耗时间；如果追求性能（查找速度）可以把填充比设大一点；如果要求节约内存，可以把扩容比设小点

   - 散列表解决哈希碰撞可以使用线性探测来解决，就是相同的value的key值往后面移动，map中的key是唯一，但是一个value可能对应的是多个key；hash冲突是不同的key经过hashCode()方法计算后的hash值相同，即分配在数组中的下标会冲突，那么就会加入到对应下标的链表上去，1.7是头插法，1.8是尾插法

   - 初始化容量参数initialCapacity只能是2的N次方，如果传入的容量不是2的N次方也会自动转化为2的N次方

   - 扩容时机：当把键值对插入到桶中或者链表（红黑数）中时，判断++size>threshold；是否大于阈值，大于就扩容；阈值为容量*负载因子，比如初始为16乘0.75=12，当map中的size为13时就开始扩容

   - 最小树化数组元素数：int MIN_TREEIFY_CAPACITY = 64；数组的元素大于等于64并且链表数大于等于8才会转换为树

   - 链表转换为数的阈值：TREEIFY_THRESHOLD = 8；

   - 树转换为链表的阈值：UNTREEIFY_THRESHOLD = 6；当树的数量减少为小于等于6时就会重构为链表

   - 字段

     ```java
     /**
          * The table, initialized on first use, and resized as
          * necessary. When allocated, length is always a power of two.
          * (We also tolerate length zero in some operations to allow
          * bootstrapping mechanics that are currently not needed.)
          */
         transient Node<K,V>[] table;
     
         /**
          * Holds cached entrySet(). Note that AbstractMap fields are used
          * for keySet() and values().
          */
         transient Set<Map.Entry<K,V>> entrySet;
     
         /**
          * The number of key-value mappings contained in this map.
          */
         transient int size;
     
         /**
          * The number of times this HashMap has been structurally modified
          * Structural modifications are those that change the number of mappings in
          * the HashMap or otherwise modify its internal structure (e.g.,
          * rehash).  This field is used to make iterators on Collection-views of
          * the HashMap fail-fast.  (See ConcurrentModificationException).
          */
         transient int modCount;
     
         /**
          * The next size value at which to resize (capacity * load factor).
          *
          * @serial
          */
         // (The javadoc description is true upon serialization.
         // Additionally, if the table array has not been allocated, this
         // field holds the initial array capacity, or zero signifying
         // DEFAULT_INITIAL_CAPACITY.)
         int threshold;
     
         /**
          * The load factor for the hash table.
          *
          * @serial
          */
         final float loadFactor;
     ```

     - AbstractMap的keySet()返回键的集合、values()反之所有值、entrySet()返回所有键值对

3. hashMap 构造函数

   - public HashMap()
   - public HashMap(int initialCapacity) 初始化容量
   - public HashMap(int initialCapacity, float loadFactor)loadFactor  为填充比
   - public HashMap(Map<!--? extends K, ? extends V--> m)  用m元素初始化散列映射

4. 我们把不同的key具有相同的hashCode()的情况称之为哈希冲突；冲突越多，该链表就越长，调用get（）方法的效率就越低，因为get方法会遍历链表

5. get()方法的执行流程；先把key经过hashCode()方法计算得hash值之后找到数组中对应的桶bakect，如果发现桶有链表，那么会遍历链表，使用equals()方法来确定相等的key所在的node结点

6. put()方法的执行流程

   - 当一个空map首次put元素时，就会按照初始容量来执行resize扩容方法；比如说初始是16，那么就会有一个16个null的node数组（Node是一个内部类）
   - 当put时，key为null时，那么put的第一步就会把hash值设为0，那么在后面的putVal方法时计算数组下标都会是0，意思就是null值都会是在数组的第一个位置，但是第一个位置不一定都是null，当有key哈希计算后在数组的第一个位置，后续的null会以链表的形式加在第一个元素后面

   ![](D:\zuo_mian\java小知识\image\20200618150149962.png)

6.线程不安全的原因

- JDK1.7死循环原因的参考视频：https://www.bilibili.com/video/BV1n541177Ea
- 多个线程执行put方法时触发扩容resize()，JDK1.7的链表遇见hash冲突时使用的是头插法，这样在扩容之后链表的顺序就会完全翻转；当这时其他线程占有的是未扩容之前的链表引用来对已经进行过扩容的链表再扩容时，那么在链表的两个结点就会互相引用，形成死循环，下次调用Map的方法就会造成CPU飙升；这个过程中还可能会导致链表中的数据丢失
- JDK1.8之后链表新增hash冲突的Entry使用的是尾插入方法，从根源上解决了死循环和数据丢失问题；但是因为HashMap修改size时不是同步的，因此会出现后面的线程把前面线程的值给覆盖了的情况（数据覆盖问题）

7.hashMap的面试问题

- 参考文档：https://gitee.com/xu207369357/hashMap-learn/blob/master/HashMap%E9%97%AE%E9%A2%98.md#3%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E5%89%8D%E9%9C%80%E5%AF%B9%E5%93%88%E5%B8%8C%E7%A0%81%E8%BF%9B%E8%A1%8C%E4%BA%8C%E6%AC%A1%E5%A4%84%E7%90%86%E6%89%B0%E5%8A%A8%E5%A4%84%E7%90%86

### 三、LinkedHashMap链接映射

- LinkedHashMap是键按照插入顺序排列的映射，有一个类似双向的迭代器链表来管理键的插入顺序

- 练手代码

  ```java
  
  ```

  

### 四、LinkedHashSet链接集

### 五、Queue队列接口

Queue接口继承Collection接口，通常来说队列都是先进先出，只有PriorityQueue优先级对应例外，它采用的是出队列的时候总是值最小元素

常用方法

```java
boolean add(E e) 
将指定的元素插入到此队列中，如果可以立即执行此操作，而不会违反容量限制， true在成功后返回 IllegalStateException如果当前没有可用空间，则抛出IllegalStateException。  
E element() 
检索，但不删除，这个队列的头。  
boolean offer(E e) 
如果在不违反容量限制的情况下立即执行，则将指定的元素插入到此队列中。  
E peek() 
检索但不删除此队列的头，如果此队列为空，则返回 null 。  
E poll() 
检索并删除此队列的头，如果此队列为空，则返回 null 。  
E remove() 
检索并删除此队列的头 
```

#### Deque双端队列接口

- 双端队列接口继承的Queue接口，可以在队头和队尾添加、删除、查看元素

- Deque还可以作为堆栈（只在栈顶添加、删除、查看元素）使用

  ```java
  push(e) addFirst(e) //Deque的addFirst(e)相当与Stack的push(e)
  pop() removeFirst()
  peek() peekFirst() 
  ```

- Deque的方法

  ```java
  boolean add(E e) 
  将指定的元素插入此双端队列表示的队列中（换句话说，在此双端队列的尾部），如果它是立即可行且不会违反容量限制，返回 true在成功时和抛出 IllegalStateException如果当前没有空间可用的。  
  void addFirst(E e) 
  插入此双端队列的前面，如果它是立即可行且不会违反容量限制，抛出一个指定的元素 IllegalStateException如果当前没有空间可用。  
  void addLast(E e) 
  在插入如果它是立即可行且不会违反容量限制，抛出此双端队列的末尾指定元素 IllegalStateException如果当前没有空间可用。  
  boolean contains(Object o) 
  如果此deque包含指定的元素，则返回 true 。  
  Iterator<E> descendingIterator() 
  以相反的顺序返回此deque中的元素的迭代器。  
  E element() 
  检索但不删除由此deque表示的队列的头部（换句话说，该deque的第一个元素）。  
  E getFirst() 
  检索，但不删除，这个deque的第一个元素。  
  E getLast() 
  检索，但不删除，这个deque的最后一个元素。  
  Iterator<E> iterator() 
  以正确的顺序返回此deque中的元素的迭代器。  
  boolean offer(E e) 
  将指定的元素插入由此deque表示的队列（换句话说，在该deque的尾部），如果可以立即执行，而不违反容量限制， true在成功时 false如果当前没有可用空间，则返回false。  
  boolean offerFirst(E e) 
  在此deque的前面插入指定的元素，除非它会违反容量限制。  
  boolean offerLast(E e) 
  在此deque的末尾插入指定的元素，除非它会违反容量限制。  
  E peek() 
  检索但不删除由此deque表示的队列的头部（换句话说，此deque的第一个元素），如果此deque为空，则返回 null 。  
  E peekFirst() 
  检索，但不删除，此deque的第一个元素，或返回 null如果这个deque是空的。  
  E peekLast() 
  检索但不删除此deque的最后一个元素，如果此deque为空，则返回 null 。  
  E poll() 
  检索并删除由此deque（换句话说，此deque的第一个元素）表示的队列的 null如果此deque为空，则返回 null 。  
  E pollFirst() 
  检索并删除此deque的第一个元素，如果此deque为空，则返回 null 。  
  E pollLast() 
  检索并删除此deque的最后一个元素，如果此deque为空，则返回 null 。  
  E pop() 
  从这个deque表示的堆栈中弹出一个元素。  
  void push(E e) 
  将元素推送到由此deque表示的堆栈（换句话说，在此deque的头部），如果可以立即执行此操作而不违反容量限制，则抛出 IllegalStateException如果当前没有可用空间）。  
  E remove() 
  检索并删除由此deque表示的队列的头（换句话说，该deque的第一个元素）。  
  boolean remove(Object o) 
  从此deque中删除指定元素的第一个出现。  
  E removeFirst() 
  检索并删除此deque的第一个元素。  
  boolean removeFirstOccurrence(Object o) 
  从此deque中删除指定元素的第一个出现。  
  E removeLast() 
  检索并删除此deque的最后一个元素。  
  boolean removeLastOccurrence(Object o) 
  从此deque中删除指定元素的最后一次出现。  
  int size() 
  返回此deque中的元素数。 
  ```


#### blockingQueue阻塞队列

- 该接口的实现类都是线程安全的，并且元素不允许为null;如果为null的话会抛出空指针异常;使用锁和Condition来实现线程安全

  ```
//添加时都有该Objects的非空检测方法
  Objects.requireNonNull(e);
  ```
```

    /** Main lock guarding all access */
    final ReentrantLock lock;
  
      /** Condition for waiting takes */
      private final Condition notEmpty;
  
      /** Condition for waiting puts */
      private final Condition notFull;
```

  

- bolckingQueue阻塞队列继承的Queue接口；

  ![image-20210526171454720](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210526171454720.png)

  - #### BlockingQueue对读取、插入、删除提供了四种不同的方法：1、抛出异常；2、返回特殊值；3、阻塞直到操作成功；4、阻塞直到成功或者超时

    #### ![](https://upload-images.jianshu.io/upload_images/5737874-5948c553b3905bdd.png?imageMogr2/auto-orient/strip|imageView2/2/w/621/format/webp)

    - 注意点：JDK11的remore()方法当队列为空时，不会抛出异常

  - blockingQueue接口的方法
  
    ```java
    boolean add(E e) 
    在队尾添加一个元素，如果队列满则抛出IllegalStateException异常
    boolean contains(Object o) 
    如果此队列包含指定的元素，则返回 true 。  
    int drainTo(Collection<? super E> c) 
    从该队列中删除所有可用的元素，并将它们添加到给定的集合中。  
    int drainTo(Collection<? super E> c, int maxElements) 
    最多从该队列中删除给定数量的可用元素，并将它们添加到给定的集合中。  
    boolean offer(E e) 
    在队尾添加一个元素，如果队列满则返回false  
    boolean offer(E e, long timeout, TimeUnit unit) 
    将指定的元素插入到此队列中，等待指定的等待时间（如有必要）才能使空间变得可用。  
    E poll(long timeout, TimeUnit unit) 
    移除并返回队头元素，如果队列空则返回null  
    void put(E e) 
    在队尾添加一个元素；如果队列满则阻塞线程  
    int remainingCapacity() 
    返回该队列最好可以（在没有存储器或资源约束）接受而不会阻塞，或附加的元素的数量 Integer.MAX_VALUE如果没有固有的限制。  
    boolean remove(Object o) 
    从该队列中删除指定元素的单个实例（如果存在）。  
    E take() 
  移除并返回队头元素；如果队列空则阻塞线程 
    ```
  
  - 练手代码
  
    ```java
    /**
         * 队列满了还加add();add()方法添加成功返回true： java.lang.IllegalStateException: Queue full
         * 队列空的情况下remove()不会抛出异常
         *队列空时element()方法会抛出异常：NoSuchElementException
         */
        static void throwEeception(){
            ArrayBlockingQueue<Object> blockingQueue = new ArrayBlockingQueue<>(3);
            System.out.println(blockingQueue.element());
            blockingQueue.remove("a");
        }
    
        /**
         *队列满了继续offer添加元素，不会抛出异常，会返回false；添加成功会返回true
         * 队列为空继续poll删除元素，不会抛出异常，会返回null；如果还有元素会返回移除的元素
         * peek()方法查看队尾元素；LinkedBlockingQueue返回的是first结点，ArrayBlockingQueue返回的是takeIndex下标所在的数组元素
         * @throws InterruptedException
         */
        static void noException() throws InterruptedException {
            //无参构造的默认容量为Integer.MAX_VALUE
            BlockingQueue<String> queue=new LinkedBlockingDeque<>(3);
            System.out.println(queue.add("a"));
            System.out.println(queue.peek());
            System.out.println(queue.poll());
        }
    
        /**
         * while (count == items.length)
         *                 notFull.await();
         * 队列满时还put()添加元素，那么就会notFull这个Condition实例的await方法阻塞当前线程，无返回值
         * while (count == 0)
         *                 notEmpty.await();
         * 队列为空时还take()移除元素，那么会调用notEmpty这个Condition实例的await()方法阻塞当前线程
         * @throws InterruptedException
         */
        static void block() throws InterruptedException {
            ArrayBlockingQueue<Object> queue = new ArrayBlockingQueue<>(3);
            queue.take();
        }
    
        /**
         * 队列满是超时等待添加，Boolean offer((E e, long timeout, TimeUnit unit)；成功返回true，失败返回false
         *队列空时超时等待移除元素，poll();实际上调用的notEmpty这个Condition对象的awaitNanos()方法，时间都是转换为纳秒
         * while (count == 0) {
         *                 if (nanos <= 0L)
         *                     return null;
         *                 nanos = notEmpty.awaitNanos(nanos);
         *             }
         * @throws InterruptedException
         */
        static void overTime() throws InterruptedException {
            ArrayBlockingQueue<Object> queue = new ArrayBlockingQueue<>(3);
            System.out.println(queue.poll(4, TimeUnit.SECONDS));
        }
    ```
  
    

#### blockingDeque接口

- 继承的是BlockingQueue接口和Deque接口；BlockingDeque方法有四种形式，不同的方式处理不能立即满足的操作，但可能在将来的某个时间点满足：一个抛出异常，第二个返回一个特殊值（ null或false ，具体取决于操作），第三个程序将无限期地阻止当前线程，直到操作成功为止，而第四个程序块在放弃之前有个超时时间，过了超时时间再阻塞等

  

  ![image-20210526172522131](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210526172522131.png)

- 方法跟BlockingQueue和Deque接口的结合类似

- 该接口的实现类都是线程安全的，并且元素不允许为null

#### 非线程安全的实现类

- ArrayDeque循环数组

  - 现在都不推荐使用Stack堆栈类，需要时都是首先考虑使用ArrayDeque，其次使用LinkedList来实现堆栈功能；循环数组是大小动态的，没有空间之后会自动扩容；有head、tail两个首尾引用标志

  - 结构

    head和tail在数组的任意位置都有可能，不一定tail在head后面

  - 扩容

    当插入后检查是否还有空间，没有空间就创建个两倍长度的循环数组，在把head右边的数复制过去，再把head左边的复制过去；插入时要检查下标是否越界、空间是否没有

  - 方法

    

- ProrityQueue优先级队列：使用的是二叉树实现的堆，元素需要实现Comparable接口，或者在构造器中加一个Comparator比较器，每次出队时都会计算出值最小的元素到根结点，然后根节点出队；一般用于任务调度时都是优先级越高，值越小（1最小优先级最高）

#### 阻塞队列实现类

- LinkedBlockingQueue

  - 基于单向链表的阻塞队列（但是源码里是双向链表，可以双向添加和删除），初始容量为Integer的最大值，可看成无上限；出队和入队使用的是两个锁，因此并发量比ArrayBlockingQueue高

    ```java
      /** Lock held by take, poll, etc */
        private final ReentrantLock takeLock = new ReentrantLock();
    
        /** Wait queue for waiting takes */
        private final Condition notEmpty = takeLock.newCondition();
    
        /** Lock held by put, offer, etc */
        private final ReentrantLock putLock = new ReentrantLock();
    
        /** Wait queue for waiting puts */
        private final Condition notFull = putLock.newCondition();
    ```

    

  - 构造函数

    ![image-20210527115223775](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210527115223775.png)

  - 适用于任务队列；线程池中固定线程大小的newFixedThreadPool、SingleThreadExecetor使用就是LinkedBlockingQueue作为该线程池的工作队列

- LinkedBlokingDeque

- ArrayBlockingQueue

  ```java
  /** Main lock guarding all access 添加删除都是使用的这一把锁，并发量就要低些 */
      final ReentrantLock lock;
  
      /** Condition for waiting takes */
      private final Condition notEmpty;
  
      /** Condition for waiting puts */
      private final Condition notFull;
  ```

  - 构造方法；参数可以为容量（必须指定容量）、是否公平、包含初始集合；底层是循环数组

    ![image-20210527113338828](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210527113338828.png)

  - ArrayBlockingQueue的容量是固定的，ArrayDeque循环数组是会自动扩容的，没有ArrayQueue这种数据结构，入队和出队使用的都是同一把锁

  - 适用于生产者消费者场景

- PriorityBlockingQueue

  - 优先级阻塞队列，容量无上限，实现为一个堆，优先队列的默认初始容量为11，没有比较器需要元素实现Comparable接口

- DelayQueue<E extends Delayed>

  - ScheduledThreadPoolExecutor线程池使用的就是DelayQueue，DelayQueue封装了一个PriorityQueue，用它来实现任务的先进先出

- TransferQueue

#### ConcurrentLinkedQueue

- 它不会阻塞线程，而是利用了 `CAS` 来保证线程的安全

  ```java
  public boolean offer(E e) {
          final Node<E> newNode = new Node<E>(Objects.requireNonNull(e));
  
          for (Node<E> t = tail, p = t;;) {
              Node<E> q = p.next;
              if (q == null) {
                  // p is last node
                  if (NEXT.compareAndSet(p, null, newNode)) {
                      // Successful CAS is the linearization point
                      // for e to become an element of this queue,
                      // and for newNode to become "live".
                      if (p != t) // hop two nodes at a time; failure is OK
                          TAIL.weakCompareAndSet(this, t, newNode);
                      return true;
                  }
                  // Lost CAS race to another thread; re-read next
              }
              else if (p == q)
                  // We have fallen off list.  If tail is unchanged, it
                  // will also be off-list, in which case we need to
                  // jump to head, from which all live nodes are always
                  // reachable.  Else the new tail is a better bet.
                  p = (t != (t = tail)) ? t : head;
              else
                  // Check for tail updates after two hops.
                  p = (p != t && t != (t = tail)) ? t : q;
          }
      }
  ```

  

#### 练手代码

- 通过获取输入的目录路径以及关键字来搜索每个文件的关键字所在行，使用数组阻塞队列；读取.md文件没有问题；但是读取.txt文件时中文出现乱码，没有解决

  ```java
  public class BlockingQueueTest {
      //阻塞队列中文件数的上限
      private static final int FILE_QUEUE_SIZE = 10;
      //搜索线程的数量
      private static final int SEARCH_THREADS = 100;
      //阻塞队列中文件结束的标志
      private static final Path DUMMY = Path.of("");
      //实例化一个阻塞数组队列，初始大小为10
      private static final BlockingQueue<Path> queue = new ArrayBlockingQueue<>(FILE_QUEUE_SIZE);
      public static void main(String[] args) {
          try (var in = new Scanner(System.in)) {
              System.out.println("输入一个目录路径：");
              String directory = in.nextLine();
              System.out.println("输入一个关键词：");
              String keyword = in.nextLine();
              Runnable enumrator = () -> {
                  try {
                      enumerate(Path.of(directory));
                      queue.put(DUMMY);
                  } catch (IOException e) {
                      e.printStackTrace();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              };
              new Thread(enumrator).start();
              for (int i = 1; i <= SEARCH_THREADS; i++) {
                  Runnable searcher = () -> {
                      try {
                          boolean done = false;
                          while (!done) {
                              Path file = queue.take();
                              if (file == DUMMY) {
                                  queue.put(file);
                                  done = true;
                              } else search(file, keyword);
                          }
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      } catch (IOException e) {
                          e.printStackTrace();
                      }
                  };
                  new Thread(searcher).start();
              }
          }
      }
      public static void enumerate(Path directory) throws IOException, InterruptedException {
          try (Stream<Path> children = Files.list(directory)) {
              for (Path child : children.collect(Collectors.toList())) {
                  if (Files.isDirectory(child))
                      enumerate(child);
                  else
                      queue.put(child);
              }
          }
      }
      public static void search(Path file, String keyword) throws IOException {
          try (Scanner in = new Scanner(file)) {
              int lineNumber = 0;
              while (in.hasNext()) {
                  lineNumber++;
                  String line = in.nextLine();
                  if (line.contains(keyword)) {
       System.out.printf("%s:%d:%s%n", file, lineNumber, line);
                  }
              }
          }
      }
  }
  ```

  

五、线程安全的集合

- ConcurrentHashMap
- ConcurrentSkipListMap
- ConcurrentSkipListSet
- ConcurrentLinkedQueue

### 三、ConcurrentHashMap

> ![JAVA 7 ConcurrentHashMap](http://www.jasongj.com/img/java/concurrenthashmap/concurrenthashmap_java7.png)
>
> <img src="https://images2018.cnblogs.com/blog/1243403/201803/1243403-20180303104853760-893858987.jpg" alt="img" style="zoom: 200%;" />
>
> ![img](https://images2018.cnblogs.com/blog/1243403/201803/1243403-20180303104830445-1532149895.jpg)

1. 作用：解决HashMap在多线程put操作会导致死循环、HashTable使用的synchronized来保证线程安全，效率低，一个线程写（put）的时候，其他线程不能读写；ConcurrentHashMap采用段分锁技术提高了在高并发下访问的效率

2. 结构：由Segment<k,v>[]数组和HashEntry<k,v>[]数组构成，Segment是一种可重入锁（ReentrantLock），HashEntry是存储键值对的，是一个链表结构（多个相同value对应一个key）；Segment结构是一种数组+链表，每个Segment包含一个HashEntry；修改HashEntry数组时，需要获得对应Segment锁，因此理论上允许Segment数组的大小（CurrencyLevel ）的线程并发

   - 字段
     - 默认的并发量：DEFAULT_CONCURRENCY_LEVEL = 16;

3. 构造方法；相比于HashMap的四个构造函数，多了一个可以设置并发量（就是segment的数量，默认是16）的构造函数

   - public ConcurrentHashMap() 
   - public ConcurrentHashMap(int initialCapacity)
   - public ConcurrentHashMap(Map<? extends K, ? extends V> m)
   - public ConcurrentHashMap(int initialCapacity, float loadFactor)
   - public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)

4. JDK1.7常用方法原理：

   - V put（K key，V value）：

     - 与HashMap的put方法的区别
       - ConcurrentHashMap的key和value都不能会null，而HashMap的key可以有一个为null，value可以多个

     - 首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put

     - 首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut()自旋获取锁。

       1. 尝试自旋获取锁
       2. 如果重试的次数达到了 MAX_SCAN_RETRIES则改为阻塞锁获取，保证能获取成功

       再结合图看看 put 的流程。

       1. 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry
       2. 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value
       3. 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。
       4. 最后会解除在 1 中所获取当前 Segment 的锁

       ```java
       final V put(K key, int hash, V value, boolean onlyIfAbsent) {
           HashEntry<K,V> node = tryLock() ? null :
               scanAndLockForPut(key, hash, value);
           V oldValue;
           try {
               HashEntry<K,V>[] tab = table;
               int index = (tab.length - 1) & hash;
               HashEntry<K,V> first = entryAt(tab, index);
               for (HashEntry<K,V> e = first;;) {
                   if (e != null) {
                       K k;
                       if ((k = e.key) == key ||
                           (e.hash == hash && key.equals(k))) {
                           oldValue = e.value;
                           if (!onlyIfAbsent) {
                               e.value = value;
                               ++modCount;
                           }
                           break;
                       }
                       e = e.next;
                   }
                   else {
                       if (node != null)
                           node.setNext(first);
                       else
                           node = new HashEntry<K,V>(hash, key, value, first);
                       int c = count + 1;
                       if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                           rehash(node);
                       else
                           setEntryAt(tab, index, node);
                       ++modCount;
                       count = c;
                       oldValue = null;
                       break;
                   }
               }
           } finally {
               unlock();
           }
           return oldValue;
       }
       ```

   - public V get(Object key)

     - get过程是比较高效的，不需要加锁，只需要通过两次hash运算就可以获得value

     - 由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值

       ```java
       public V get(Object key) {
           Segment<K,V> s; // manually integrate access methods to reduce overhead
           HashEntry<K,V>[] tab;
           int h = hash(key);
           long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
           if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
               (tab = s.table) != null) {
               //遍历链表，如果存在链表的话，用的是key.equals(k)
               for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObj4ectVolatile
                        (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
                    e != null; e = e.next) {
                   K k;
                   if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                       return e.value;
               }
           }
           return null;
       }
       ```

   - public int size()

     - 因为统计过程中hashEntry的数量可能发生变化，但是几率很小；就有了尝试+比较机制，先尝试两次不锁，通过比较前后的modCount变量是否发生了变化（每次put、remove、clean方法modCount都会加1），如果modCount变了就是容器大小变了，那么需要采用加锁的方式统计所有Segment的大小，这时对Map无法读和写

       ```java
       public int size() {
         final Segment<K,V>[] segments = this.segments;
         int size;
         boolean overflow; // true if size overflows 32 bits
         long sum;         // sum of modCounts
         long last = 0L;   // previous sum
         int retries = -1; // first iteration isn't retry
         try {
           for (;;) {
             if (retries++ == RETRIES_BEFORE_LOCK) {
               for (int j = 0; j < segments.length; ++j)
                 ensureSegment(j).lock(); // force creation
             }
             sum = 0L;
             size = 0;
             overflow = false;
             for (int j = 0; j < segments.length; ++j) {
               Segment<K,V> seg = segmentAt(segments, j);
               if (seg != null) {
                 sum += seg.modCount;
                 int c = seg.count;
                 if (c < 0 || (size += c) < 0)
                   overflow = true;
               }
             }
             if (sum == last)
               break;
             last = sum;
           }
         } finally {
           if (retries > RETRIES_BEFORE_LOCK) {
             for (int j = 0; j < segments.length; ++j)
               segmentAt(segments, j).unlock();
           }
         }
         return overflow ? Integer.MAX_VALUE : size;
       }
       ```

#### JDK1.8的ConcurrentHashMap

- put方法

  - 当首次使用put时，会先初始化表
  - 不是首次，会先判断经过&运算之后的数组下标位置的元素是否为null；
  - 为null则表示可以添加node键值对，先用CAS操作是否能插入成功，如果能插入成功（表示该结点无锁）则直接返回
  - 如果CAS插入失败则用synchronized加锁（锁是将要插入的Node对象）

  ```java
   final V putVal(K key, V value, boolean onlyIfAbsent) {
          if (key == null || value == null) throw new NullPointerException();
          int hash = spread(key.hashCode());
          int binCount = 0;
          for (Node<K,V>[] tab = table;;) {
              Node<K,V> f; int n, i, fh; K fk; V fv;
              //首次使用put初始化表
              if (tab == null || (n = tab.length) == 0)
                  tab = initTable();
              else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                  if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))
                      break;                   // no lock when adding to empty bin
              }
              else if ((fh = f.hash) == MOVED)
                  tab = helpTransfer(tab, f);
              else if (onlyIfAbsent // 在无锁的情况下检查第一个节点
                       && fh == hash
                       && ((fk = f.key) == key || (fk != null && key.equals(fk)))
                       && (fv = f.val) != null)
                  return fv;
              else {
                  V oldVal = null;
                  synchronized (f) {
                      if (tabAt(tab, i) == f) {
                          if (fh >= 0) {
                              binCount = 1;
                              for (Node<K,V> e = f;; ++binCount) {
                                  K ek;
                                  if (e.hash == hash &&
                                      ((ek = e.key) == key ||
                                       (ek != null && key.equals(ek)))) {
                                      oldVal = e.val;
                                      if (!onlyIfAbsent)
                                          e.val = value;
                                      break;
                                  }
                                  Node<K,V> pred = e;
                                  if ((e = e.next) == null) {
                                      pred.next = new Node<K,V>(hash, key, value);
                                      break;
                                  }
                              }
                          }
                          else if (f instanceof TreeBin) {
                              Node<K,V> p;
                              binCount = 2;
                              if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                             value)) != null) {
                                  oldVal = p.val;
                                  if (!onlyIfAbsent)
                                      p.val = value;
                              }
                          }
                          else if (f instanceof ReservationNode)
                              throw new IllegalStateException("Recursive update");
                      }
                  }
                  if (binCount != 0) {
                      if (binCount >= TREEIFY_THRESHOLD)
                          treeifyBin(tab, i);
                      if (oldVal != null)
                          return oldVal;
                      break;
                  }
              }
          }
          addCount(1L, binCount);
          return null;
      }
  ```

  

### 四、EnumMap枚举映射

1. EnumMap相对于hashMap的不同点

   - EnumMap的Key使用的是枚举类型，枚举类型的HashMap使用EnumMap可以减少空间的使用，并且效率最高

   - 原理是通过key是Enum类型，直接就对应了内部数组的索引，减少了计算hashCode（）的步骤

     ```java
             Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class);
             map.put(DayOfWeek.MONDAY, "星期一");
             map.put(DayOfWeek.TUESDAY, "星期二");
             map.put(DayOfWeek.WEDNESDAY, "星期三");
             map.put(DayOfWeek.THURSDAY, "星期四");
             map.put(DayOfWeek.FRIDAY, "星期五");
             map.put(DayOfWeek.SATURDAY, "星期六");
             map.put(DayOfWeek.SUNDAY, "星期日");
             System.out.println(map);
             System.out.println(map.get(DayOfWeek.MONDAY));
     ```

### 五、EnumSet枚举集

- EnumSet枚举类型元素集，内部用位序列实现，对应的值在集中则置为1，比较高效

- 练手代码

  ```java
  public class EnumSetTest {
  	enum WeekDay{MONDAY,TUSDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY};
  public static void main(String[] args) {
  	EnumSet<WeekDay> always= EnumSet.allOf(WeekDay.class);
  	EnumSet<WeekDay> never= EnumSet.noneOf(WeekDay.class);
  	EnumSet<WeekDay> workday= EnumSet.range(WeekDay.TUSDAY,WeekDay.SATURDAY);
  	EnumSet<WeekDay> workOf= EnumSet.of(WeekDay.TUSDAY,WeekDay.SATURDAY);
  	for(WeekDay w:always){
  		System.out.println(w);
  	}
  	System.out.println("-----------");
  	for(WeekDay w:never){
  		System.out.println(w);
  	}
  	System.out.println("-----------");
  	for(WeekDay w:workday){
  		System.out.println(w);
  	}
  	System.out.println("-----------");
  	for(WeekDay w:workOf){
  		System.out.println(w);
  	}
  }
  }
  ```

  ![image-20210524203534431](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210524203534431.png)

### 五、TreeMap

1. TreeMap类实现的是SortedMap接口，按照key的顺序排序的；放入的key所在类必须实现Comparable接口或者在TreeMap的构造方法中创建Comparator的对象并实现compare()方法，里面主要用compareTo()方法，这是String里面的

   

   ```java
   public class Main {
       public static void main(String[] args) {
           Map<Student, Integer> map = new TreeMap<Student,Integer>(new Comparator<Student>() {
               public int compare(Student p1, Student p2) {
                   return p1.name.compareTo(p2.name);//等于return p1.score>p2.score?1:-1;再在前面加上if判断相等的情况下返回0 的代码
               }
           });
           map.put(new Student("Tom", 77), 1);
           map.put(new Student("Bob", 66), 2);
           map.put(new Student("Lily", 99), 3);
           for (Student key : map.keySet()) {
               System.out.println(key);
           }
           System.out.println(map.get(new Student("Bob", 66))); // null?
       }
   }
   
   class Student {
       public String name;
       public int score;
       Student(String name, int score) {
           this.name = name;
           this.score = score;
       }
       /**
        * student类不写toString方法的话，上面for循环里面的输出key输出的就是类名@哈希码
        */
       public String toString() {
           return String.format("{%s: score=%d}", name, score);
       }
   }
   ```

2. Comparator接口要求实现一个比较方法，它负责比较传入的两个元素a和b，如果a<b，则返回负数，通常是-1，如果a==b，则返回0，如果a>b，则返回正数，通常是1。TreeMap内部根据比较结果对Key进行排序。

3. TreeMap不使用equals()和hashCode()



### 六、LinkedMultiValueMap

- LinkedMultiValueMap，即一个键对应多个值；不是线程安全的

- 应用场景：

  - 在SpringBoot中使用MultipartFile时，默认会生成StandardServletMultipartResolver对象，里面在把HttpServletRequest转换为MultipartHttpServletRequest时用LinkedMultiValueMap来接收HttpServletRequest里面的parts对象

    ```java
    private void parseRequest(HttpServletRequest request) {
    		try {
    			Collection<Part> parts = request.getParts();
    			this.multipartParameterNames = new LinkedHashSet<>(parts.size());
    			MultiValueMap<String, MultipartFile> files = new LinkedMultiValueMap<>(parts.size());
    			for (Part part : parts) {
    				String headerValue = part.getHeader(HttpHeaders.CONTENT_DISPOSITION);
    				ContentDisposition disposition = ContentDisposition.parse(headerValue);
    				String filename = disposition.getFilename();
    				if (filename != null) {
    					if (filename.startsWith("=?") && filename.endsWith("?=")) {
    						filename = MimeDelegate.decode(filename);
    					}
    					files.add(part.getName(), new StandardMultipartFile(part, filename));
    				}
    				else {
    					this.multipartParameterNames.add(part.getName());
    				}
    			}
    			setMultipartFiles(files);
    		}
    		catch (Throwable ex) {
    			handleParseFailure(ex);
    		}
    	}
    ```

    

  - HttpHeader类中存储的heade使用的MultiValueMap接口，该接口只有LinkedMultiValueMap实现类

    ```java
    final MultiValueMap<String, String> headers
    ```

  

- 方法

  添加一个Key对应一个Value的：void add(K, V);

  添加一个Key对应多个Value的：void add(K, List);

  设置一个Key对应一个Value的：void set(K, V);

  设置一个Key对应多个Value的：void set(K, List);

  移除一个Key和它对应的Value：List remove(K);

  清除所有Value的：void clear();

  拿到所有Key的集合：Set keySet();

  拿到所有的值：List values();

  拿到一个Key对应的某个值：V getValue(K, index);

  拿到一个Key对应的所有Value：List getValues(K);

  拿到MultiValueMap的大小：int size();

  判断是否为空MultiValueMap：boolean isEmpty();

  判断是否包含某个Key：boolean containKey(K);

- 测试

LinkedMultiValueMap<String, String> linkedMultiValueMap = new LinkedMultiValueMap<>();

linkedMultiValueMap.add("name", "t1");

linkedMultiValueMap.add("name", "t2");

linkedMultiValueMap.add("name", "t3");

for (Entry<String, List<String>> entry : linkedMultiValueMap.entrySet()) {

System.out.println(entry.getKey() + entry.getValue());

           //List<String> value = entry.getValue();

}

打印结果为 name[t1, t2, t3]

### 六、HashSet

- 实质上就是HashMap；因此初始化容量16和负载因子0.75跟HashMap的一样

  ![image-20210501152917570](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210501152917570.png)

- 几种构造函数

  ```java
   public HashSet() {
          map = new HashMap<>();
      }
       public HashSet(Collection<? extends E> c) {
          map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
          addAll(c);
      }
        public HashSet(int initialCapacity, float loadFactor) {
          map = new HashMap<>(initialCapacity, loadFactor);
      }
        public HashSet(int initialCapacity) {
          map = new HashMap<>(initialCapacity);
      }
   HashSet(int initialCapacity, float loadFactor, boolean dummy) {
          map = new LinkedHashMap<>(initialCapacity, loadFactor);
      }
  ```

  ![image-20210501163329438](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210501163329438.png)

- 最常用的add(E)方法，实际上调用的是HashMap的putVal(hash(key),k key,V valboolean onlyIfAbsent,boolean evict)；首先通过key的hash值与数组长度进行&运算得到Node数组的下标，看在该下标的数组的值是不是null，如果为null，怎添加进Node数组中；如果不为null，则继续通过equals()方法比较刚才Node数组的值可准备添加的key比较（如果该key没有重写Object中的equals方法，那么用==比较，如String重写了equals方法，那么比较值），如果相同，那么说明Node数组中有相同的值，如果不同，那么说明是不同的hash冲突，在Node的next上添加新的Node

  ```java
    public boolean add(E e) {
        //如果map集合里面有相同的值，那么就会返回一个值，方法就会返回flase，表示add失败
          return map.put(e, PRESENT)==null;
      }
  ```

  

  ```java
  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                     boolean evict) {
          Node<K,V>[] tab; Node<K,V> p; int n, i;
          if ((tab = table) == null || (n = tab.length) == 0)
              n = (tab = resize()).length;
          if ((p = tab[i = (n - 1) & hash]) == null)
              tab[i] = newNode(hash, key, value, null);
          else {
              Node<K,V> e; K k;
              if (p.hash == hash &&
                  ((k = p.key) == key || (key != null && key.equals(k))))
                  e = p;
              else if (p instanceof TreeNode)
                  e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
              else {
                  for (int binCount = 0; ; ++binCount) {
                      if ((e = p.next) == null) {
                          p.next = newNode(hash, key, value, null);
                          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                              treeifyBin(tab, hash);
                          break;
                      }
                      if (e.hash == hash &&
                          ((k = e.key) == key || (key != null && key.equals(k))))
                          break;
                      p = e;
                  }
              }
              if (e != null) { // existing mapping for key
                  V oldValue = e.value;
                  if (!onlyIfAbsent || oldValue == null)
                      e.value = value;
                  afterNodeAccess(e);
                  return oldValue;
              }
          }
          ++modCount;
          if (++size > threshold)
              resize();
          afterNodeInsertion(evict);
          return null;
      }
  ```

  > ![image-20210501171112897](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210501171112897.png)

### 七、LinkedHashMap

### 七、常用接口

#### Comparable接口

- comparable接口有compareTo方法

#### Comparator接口

### 八、三大接口

- Collection除了Map之外的所有集合的根接口；集合是由若干个确定的元素所构成的整体；数组是由一组相同类型的元素构成的整体；

  - List；一种有序列表的集合，常用的实现类有ArrayList、LinkedList、Vecotr、Stack

  - Set；一种保证没有重复元素的集合，常用的实现类有HashSet、LinkedHashSet、TreeSet

  - Map；一种通过键值（Key-Value）查找的映射表集合，常用的实现类有HashMap、LinkedHashMap、TreeMap、HashTable

  - Collection接口

    ![image-20210526164029596](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210526164029596.png)

    ```java
    boolean add(E e) 
    确保此集合包含指定的元素（可选操作）。  
    boolean addAll(Collection<? extends E> c) 
    将指定集合中的所有元素添加到此集合（可选操作）。  
    void clear() 
    从此集合中删除所有元素（可选操作）。  
    boolean contains(Object o) 
    如果此集合包含指定的元素，则返回 true 。  
    boolean containsAll(Collection<?> c) 
    如果此集合包含指定 集合中的所有元素，则返回true。  
    boolean equals(Object o) 
    将指定的对象与此集合进行比较以获得相等性。  
    int hashCode() 
    返回此集合的哈希码值。  
    boolean isEmpty() 
    如果此集合不包含元素，则返回 true 。  
    Iterator<E> iterator() 
    返回此集合中的元素的迭代器。  
    default Stream<E> parallelStream() 
    返回可能并行的 Stream与此集合作为其来源。  
    boolean remove(Object o) 
    从该集合中删除指定元素的单个实例（如果存在）（可选操作）。  
    boolean removeAll(Collection<?> c) 
    删除指定集合中包含的所有此集合的元素（可选操作）。  
    default boolean removeIf(Predicate<? super E> filter) 
    删除满足给定谓词的此集合的所有元素。  
    boolean retainAll(Collection<?> c) 
    仅保留此集合中包含在指定集合中的元素（可选操作）。  
    int size() 
    返回此集合中的元素数。  
    default Spliterator<E> spliterator() 
    创建一个Spliterator在这个集合中的元素。  
    default Stream<E> stream() 
    返回以此集合作为源的顺序 Stream 。  
    Object[] toArray() 
    返回一个包含此集合中所有元素的数组。  
    <T> T[] toArray(T[] a) 
    返回包含此集合中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型 
    ```

    

- #### List

  - 数组的增加和删除操作实现比较麻烦，删除是把指定位置之后的元素往前面覆盖，指定位置添加是位置之后的元素后移，为要添加的元素腾出位置；数组的查找时间复杂度是1，为常数；数组的缺点就是初始化的时候大小就固定了

  - List<E>接口，可以看到几个主要的接口方法：

    - 在末尾添加一个元素：boolean add(E e)

    - 在指定索引添加一个元素：boolean add(int index, E e)

    - 删除指定索引的元素：int remove(int index)

    - 删除某个元素：int remove(Object 

    - 获取指定索引的元素：E get(int index)

    - 获取链表大小（包含元素的个数）：int size()

    - 以下是继承的Collection接口中没有的方法

      ```java
      List<E> subList(int fromIndex, int toIndex) 
      返回此列表中指定的 fromIndex （含）和 toIndex之间的视图。 
      boolean addAll(int index, Collection<? extends E> c) 
      将指定集合中的所有元素插入到此列表中的指定位置（可选操作）。  
       E get(int index) 
      返回此列表中指定位置的元素。 
          int indexOf(Object o) 
      返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 
          int lastIndexOf(Object o) 
      返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。 
          ListIterator<E> listIterator() 
      返回列表中的列表迭代器（按适当的顺序）。 
          ListIterator<E> listIterator(int index) 
      从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 
          E set(int index, E element) 
      用指定的元素（可选操作）替换此列表中指定位置的元素。 
          default void replaceAll(UnaryOperator<E> operator) 
      将该列表的每个元素替换为将该运算符应用于该元素的结果。 
          default void sort(Comparator<? super E> c) 
      使用随附的 Comparator排序此列表来比较元素。 
      ```

      

  - 把一个list对象转换成数组；Integer[] array = list.toArray(new Integer[list.size()]);

  - 把数组转换成list；

    ```java
    Integer[] array = { 1, 2, 3 };
    //List.of()方法转换成的列表是只读的，不能修改
    List<Integer> list = List.of(array);
    //对于JDK11之前可以使用Arrays.aList(T e)
    List<Integer> lst=Arrays.aList(array);
    ```

- Set

  - Set接口，Set是没有重复元素的集；继承的是Collection接口

  - Set中的方法在Collection接口中都有

    ```java
    boolean add(E e) 
    如果指定的元素不存在，则将其指定的元素添加（可选操作）。  
    boolean addAll(Collection<? extends E> c) 
    将指定集合中的所有元素添加到此集合（如果尚未存在）（可选操作）。  
    void clear() 
    从此集合中删除所有元素（可选操作）。  
    boolean contains(Object o) 
    如果此集合包含指定的元素，则返回 true 。  
    boolean containsAll(Collection<?> c) 
    返回 true如果此集合包含所有指定集合的元素。  
    boolean equals(Object o) 
    将指定的对象与此集合进行比较以实现相等。  
    int hashCode() 
    返回此集合的哈希码值。  
    boolean isEmpty() 
    如果此集合不包含元素，则返回 true 。  
    Iterator<E> iterator() 
    返回此集合中元素的迭代器。  
    boolean remove(Object o) 
    如果存在，则从该集合中删除指定的元素（可选操作）。  
    boolean removeAll(Collection<?> c) 
    从此集合中删除指定集合中包含的所有元素（可选操作）。  
    boolean retainAll(Collection<?> c) 
    仅保留该集合中包含在指定集合中的元素（可选操作）。  
    int size() 
    返回此集合中的元素数（其基数）。  
    default Spliterator<E> spliterator() 
    在此集合中的元素上创建一个 Spliterator 。  
    Object[] toArray() 
    返回一个包含此集合中所有元素的数组。  
    <T> T[] toArray(T[] a) 
    返回一个包含此集合中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型 
    ```

    

- Map

  - Map接口，Map接口跟Collection接口是同级的，Map没有继承任何接口

    ```java
    void clear() 
    从该地图中删除所有的映射（可选操作）。  
    default V compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) 
    尝试计算指定键的映射及其当前映射的值（如果没有当前映射， null ）。  
    default V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction) 
    如果指定的键尚未与值相关联（或映射到 null ），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非 null 。  
    default V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) 
    如果指定的密钥的值存在且非空，则尝试计算给定密钥及其当前映射值的新映射。  
    boolean containsKey(Object key) 
    如果此映射包含指定键的映射，则返回 true 。  
    boolean containsValue(Object value) 
    如果此地图将一个或多个键映射到指定的值，则返回 true 。  
    Set<Map.Entry<K,V>> entrySet() 
    返回此地图中包含的映射的Set视图。  
    boolean equals(Object o) 
    将指定的对象与此映射进行比较以获得相等性。  
    default void forEach(BiConsumer<? super K,? super V> action) 
    对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。  
    V get(Object key) 
    返回到指定键所映射的值，或 null如果此映射包含该键的映射。  
    default V getOrDefault(Object key, V defaultValue) 
    返回到指定键所映射的值，或 defaultValue如果此映射包含该键的映射。  
    int hashCode() 
    返回此地图的哈希码值。  
    boolean isEmpty() 
    如果此地图不包含键值映射，则返回 true 。  
    Set<K> keySet() 
    返回此地图中包含的键的Set视图。  
    default V merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction) 
    如果指定的键尚未与值相关联或与null相关联，则将其与给定的非空值相关联。  
    V put(K key, V value) 
    将指定的值与该映射中的指定键相关联（可选操作）。  
    void putAll(Map<? extends K,? extends V> m) 
    将指定地图的所有映射复制到此映射（可选操作）。  
    default V putIfAbsent(K key, V value) 
    如果指定的键尚未与某个值相关联（或映射到 null ）将其与给定值相关联并返回 null ，否则返回当前值。  
    V remove(Object key) 
    如果存在（从可选的操作），从该地图中删除一个键的映射。  
    default boolean remove(Object key, Object value) 
    仅当指定的密钥当前映射到指定的值时删除该条目。  
    default V replace(K key, V value) 
    只有当目标映射到某个值时，才能替换指定键的条目。  
    default boolean replace(K key, V oldValue, V newValue) 
    仅当当前映射到指定的值时，才能替换指定键的条目。  
    default void replaceAll(BiFunction<? super K,? super V,? extends V> function) 
    将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。  
    int size() 
    返回此地图中键值映射的数量。  
    Collection<V> values() 
    返回此地图中包含的值的Collection视图 
    ```

    

  - 常用的方法有put(K key,V value),V get(Object key), Key contains(V value),V contains(K key),remove(K key),int size(),Collection<V> values()返回map中包含的值的集合

  - 遍历Map的时候输出的值的顺序是不能保障的；Map的查找和插入的时间复杂度都是常数；Map中的Key都是不重复的，如果重复插入相同key的键值对，那么旧value将会被覆盖

    - 使用map的KeySet()来遍历

      ```java
       Map<String, Integer> map = new HashMap<>();
              map.put("apple", 123);
              map.put("pear", 456);
              map.put("banana", 789);
              for (String key : map.keySet()) {
                  Integer value = map.get(key);
                  System.out.println(key + " = " + value);
              }
      ```

    - 使用map的entrySet()来遍历

      ```java
       Map<String, Integer> map = new HashMap<>();
              map.put("apple", 123);
              map.put("pear", 456);
              map.put("banana", 789);
              for (Map.Entry<String, Integer> entry : map.entrySet()) {
                  String key = entry.getKey();
                  Integer value = entry.getValue();
                  System.out.println(key + " = " + value);
              }
      ```

  - 使用Map来充当实体类里的缓存，用来存储实体对象

    ```java
    public class Main {
    	    public static void main(String[] args) {
    	    	List<Student> list = new ArrayList<Student>();
    	    	Student Bob=new Student("Alice", 78);
    	    	Student Brush=new Student("Brush", 66);
    	    	Student Newton=new Student("Newton", 99);
    	    	list.add(Bob);
    	    	list.add(Brush);
    	    	list.add(Newton);
    	        Students holder = new Students(list);
    	        System.out.println(holder.getScore("Brush") == 66 ? "测试成功!" : "测试失败!");
    	        System.out.println(holder.getScore("Alice") == 78 ? "测试成功!" : "测试失败!");
    	        System.out.println(holder.getScore("Tom") == -1 ? "测试成功!" : "测试失败!");
    	        System.out.println(holder.findInList("Brush"));
    	    }
    	}
    
    	class Students {
    	    List<Student> list;
    	    Map<String, Integer> cache;
    
    	    Students(List<Student> list) {
    	        this.list = list;
    	        cache = new HashMap<String, Integer>();
    	        for(Student student:this.list){
    	        	cache.put(student.name, student.score);
    	        }
    	    }
    
    	    /**
    	     * 根据name查找score，找到返回score，未找到返回-1
    	     */
    	    int getScore(String name) {
    	        // 先在Map中查找:
    	        Integer score = this.cache.get(name);
    	        if (score == null) {
    	            // TODO:
    	        }
    	        return score == null ? -1 : score.intValue();
    	    }
    
    	    Integer findInList(String name) {
    	        for (Student ss : this.list) {
    	            if (ss.name.equals(name)) {
    	                return ss.score;
    	            }
    	        }
    	        return null;
    	    }
    	}
    
    	class Student {
    	    String name;
    	    int score;
    
    	    Student(String name, int score) {
    	        this.name = name;
    	        this.score = score;
    	    }
    	}
    
    
    ```

    上面代码的好在使用三目运算符、Integer.intValue()拆箱、for each循环、student类与students类的分开处理、类里面只定义对象只在运行时才初始化、对于String引用类型使用equals(Object o)来比较值

  - Map的实现类HashMap，在Map中插入多个相同key时，Map内部使用的是equals()方法来比较的（比较的是值），因此

    ```java
    public static void main(String[] args) {
    	    	String key1 = "a";
    	        Map<String, Integer> map = new HashMap<String,Integer>();
    	        map.put(key1, 123);
    	        String key2 = new String("a");
    	        map.put(key2, 456);
    	        System.out.println(map.get(key2));
    	        System.out.println(map.get(key1));
    	        System.out.println(key1 == key2); // false
    	        System.out.println(key1.equals(key2)); // true
    	    }
    ```

    上面程序输出的都是456，new String("a")和上面的"a"的值都是一样的，内存地址不一样；

  - 跟List查找元素所在类需要重写equals()方法一样，作为Map的key所在类也需要重写equals方法、hashCode()方法，自定义的类对象要作为Map的key时，就需要在类中重写equals()和hashCode()方法，equals()重写跟List的一样,hashCode()的重写如下；

    ```java
    public class Person {
        String firstName;
        String lastName;
        int age;
    
        @Override
        int hashCode() {
            int h = 0;
            h = 31 * h + firstName.hashCode();
            h = 31 * h + lastName.hashCode();
            h = 31 * h + age;
            return h;
        }
    }
    ```

    用31*h是为了把每个person对象的hashCode打散在int的+-21亿之间，分散开，尽量实现

    - 如果两个对象相等，则两个对象的hashCode()必须相等；
    - 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。

  - 上面的firstName和lastName字段为null的时候，

  - 用一个大数组存储所有value，通过key计算索引的方式就是调用key对象的hashCode()方法，它返回一个int整数。HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value：

    ```ascii
      ┌───┐
    0 │   │
      ├───┤
    1 │ ●─┼───> Person("Xiao Ming")
      ├───┤
    2 │   │
      ├───┤
    3 │   │
      ├───┤
    4 │   │
      ├───┤
    5 │ ●─┼───> Person("Xiao Hong")
      ├───┤
    6 │ ●─┼───> Person("Xiao Jun")
      ├───┤
    7 │   │
      └───┘
    ```

### 九、线程安全的集合

- 并发修改异常测试：ConcurrentModificationException

  ```java
   /**
       *  注意：下述的测试，都是add时不会出现并发修改异常，之后add后还要查询整个集合才会出现
       */
      public static void main(String[] args) {
          Map map=new ConcurrentSkipListMap();
          map1(map);
      }
      /**
       * 这样在mian函数里开很多线程来调用collection（）方法都不会出现并发异常
       */
      static void collection(List list){
          for (int i = 0; i < 1000; i++) {
              list.add(new Random().nextInt(1000));
              System.out.println(list);
          }
      }
      /**
       * 这种情况就会出现：ConcurrentModificationException并发修改异常
       * 线程安全的list；
       *      * 1.使用List<Object> list =  Collections.synchronizedList(new ArrayList<>());
       *      * 注意：上述方法的返回值是List，，用ArrayList来接收的话还是会出现转换异常或者并发修改异常
       *      * 2.使用List list = new  CopyOnWriteArrayList(); 该类是JUC包下的复制写的线程安全的List
       */
      static void c2(List list){
          for (int i = 0; i < 100; i++) {
              new Thread(()->{list.add(new Random().nextInt(1000));}).start();
              System.out.println(list);
          }
      }
  
      /**
       * 线程安全的Set
       * 1.Set set=Collections.synchronizedSet(new HashSet());
       * 2.复制写Set：Set set=new CopyOnWriteArraySet();
       * 3.并发跳跃表集合： Set set=new ConcurrentSkipListSet();
       * @param set
       */
      static void set1(Set set){
          for (int i = 0; i < 100; i++) {
              new Thread(()->{
                  //这里添加的数为Random类随机生成的int类型的数才会出现并发修改异常，为什么UUID生成的不行？
                  set.add(new Random().nextInt(10));
                  System.out.println(set);
              }).start();
          }
      }
  
      /**
       * 线程安全的Map
       * 1.Map map=Collections.synchronizedMap(new HashMap<>());
       * 2.Map map=new ConcurrentHashMap();
       * 3.并发跳跃表Map：Map map=new ConcurrentSkipListMap();
       * @param map
       */
      static void map1(Map map){
          for (int i = 0; i < 100; i++) {
              new Thread(()->{
                  map.put(UUID.randomUUID(),new Random().nextInt(100));
                  System.out.println(map);
              }).start();
          }
      }
  ```

  

### 十、面试题

#### LinkedList和ArrayList的区别

#### 去除List中的重复元素

- 不新建空间，只用原列表用两层for循环

  ```
  // 使用时间换空间，删除ArrayList中重复元素 ，下面的方式是删除的后面的重复元素，也是有序的
   public  static   void removeDuplicate1(List list)  {
     for  ( int  i =   0 ; i <  list.size() -   1 ; i ++)   {
      for  ( int  j =  list.size() -   1 ; j >  i; j --)   {
        if (list.get(j).equals(list.get(i)))  {
          list.remove(j);
        }
      }
     }
    System.out.println(list);
   }
  ```

  

- 新建新列表，使用列表的contains方法；往新列表里面添加元素，新列表里面有了的就不添加了

  ```
  //使用List的contains()方法实现，特点是需要新建一个列表；该方法有序的
  List<String> list= new ArrayList<>();
      for (String s:words) {
        if (!list.contains(s)) {
          list.add(s);
        }
      }
  ```

  

- 使用set；利用set集合的无重复元素的特性，利用hashSet的一个构造函数参数为collection来构造set，然后把原列表清空，在用list的addAll方法把set添加进去；LinkedHashSet最好，用list最为LinkedHashSet构造函数的参数构造一个有序的set集合；如果使用HashSet就是无序的

  ```
  //LinkedHashSet实现
  List<String> words= Arrays.asList("a","b","b","c","c","d");
  HashSet<String> set=new LinkedHashSet<>(words);
  for(String word:set){
     System.out.println(word);
  }
  //HashSet实现，该方法是无序的
  List<String> words= Arrays.asList("a","b","b","c","c","d");
  for(String word:words){
    set.add(word);
  }
  for(String word:set){
    System.out.println(word);
  }
  ```

  

- 使用Stream流的distinct方法直接去除重复元素

  ```
  //Java8的流实现
  List<String> words= Arrays.asList("a","b","b","c","c","d");
  words.stream().distinct().collect(Collectors.toList()).forEach(System.out::println);
  ```

- ArrayList和HashMap

  ArrayList可以存储多个null值并且会占用size大小；而HashMap只能存储一个null值，添加多个null键值对map的大小也只是1

  应用场景：在add的时候如果不想存储null值应该先做一个null值判断

#### ConcurrentHashMap线程安全的原理

#### HashMap中的面试题

#### ArrayList中的面试题

- ArrayList为什么不是线程安全的？不安全的表现

  - 第一种情况：当add方法触发了扩容方法grow，就会有调用Arrays.copy()来返回一个新的elementDate数组；多线程情况下就有可能同时有两个线程同时进入grow方法，那么就会返回两个新数组，后面返回的数组就会把前面返回的数组数据覆盖，那么就会造成前面线程所添加数据的丢失

  - 第二种情况

    黄色框里的并不是一个原子操作，它由两步操作构成：

    ```
    elementData[size] = e;
    size = size + 1;
    ```

    在单线程执行这两条代码时，那当然没有任何问题，但是当多线程环境下执行时，可能就会发生**一个线程添加的值覆盖另一个线程添加的值**。举个例子：

    - 假设 size = 0，我们要往这个数组的末尾添加元素
    - 线程 A 开始添加一个元素，值为 A。此时它执行第一条操作，将 A 放在了数组 elementData 下标为 0 的位置上
    - 接着线程 B 刚好也要开始添加一个值为 B 的元素，且走到了第一步操作。此时线程 B 获取到的 size 值依然为 0，于是它将 B 也放在了 elementData 下标为 0 的位置上
    - 线程 A 开始增加 size 的值，size = 1
    - 线程 B 开始增加 size 的值，size = 2

    这样，线程 A、B 都执行完毕后，理想的情况应该是 size = 2，elementData[0] = A，elementData[1] = B。而实际情况变成了 size = 2，elementData[0] = B（线程 B 覆盖了线程 A 的操作），下标 1 的位置上什么都没有。并且后续除非我们使用 set 方法修改下标为 1 的值，否则这个位置上将一直为 null，因为在末尾添加元素时将会从 size = 2 的位置上开始

- ArrayList扩容原理？每次扩容是原来size的1.5倍
- Arrays.copyOf返回的是原始对象、还是新对象？新对象
- 如果让ArrayList变成线程安全的？
  List list1 = Collections.synchronizedList(new ArrayList());
  或者用List list1 = new Vector();
- ArrayList 具体是怎么添加数据的；添加之前先判断数组是否满了，满了就需要扩容；之后调用Systems.arraycopy方法，再来看看 `add` 方法的核心 `System.arraycopy`，这个方法有 5 个参数：
  - elementData：源数组
  - index：从源数组中的哪个位置开始复制
  - elementData：目标数组
  - index + 1：复制到目标数组中的哪个位置
  - size - index：要复制的源数组中数组元素的数量

![image-20210706212647445](D:\zuo_mian\java小知识\image\image-20210706212647445.png)

![image-20210706212832897](D:\zuo_mian\java小知识\image\image-20210706212832897.png)

因此得出结论：使用指定添加位置的add(int index,E elemente)需要新创建一个数组，然后再把旧数组复制过去；而使用add(E elmente)的尾部插入方式就没有数组的移动，直接添加了，效率更高